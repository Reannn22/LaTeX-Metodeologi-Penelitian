% ===================================================================
% MAIN.TEX - Proposal Penelitian Tugas Akhir
% Program Studi Teknik Informatika - Institut Teknologi Sumatera
% ===================================================================

\documentclass[11pt,a4paper]{article}

% ===================================================================
% PACKAGE CONFIGURATION
% ===================================================================

% Margin dan Geometri
\usepackage[a4paper, top=3cm, bottom=3cm, left=4cm, right=3cm]{geometry}
\usepackage{indentfirst}

% Font dan Bahasa
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[indonesian]{babel}

% Spasi
\usepackage{setspace}
\onehalfspacing

% Package Tambahan
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{enumitem}
\usepackage{nameref}
\usepackage{tikz}
\usepackage{multirow}
\usepackage{array}
\usepackage{ragged2e}
\usepackage{comment}
\usepackage{float}

% === TAMBAHKAN 3 BARIS INI ===
\usepackage{tocloft}
\setlength{\cftsecnumwidth}{0pt}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
% ==============================

% Header dan Footer setup
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Reyhan Capri Moraga (123140022)}
\rhead{\thepage}
\cfoot{\textbf{Perbandingan Efisiensi REST API dan GraphQL pada Sistem Penjadwalan Perkuliahan Berbasis Cloud-Native dengan Docker, Kubernetes, dan Load Balancing}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Section formatting
\usepackage{titlesec}
\titleformat{\section}
{\normalfont\Large\bfseries\centering}
{}{0pt}{\MakeUppercase}

% --- TAMBAHKAN DUA BARIS INI ---
\titleformat{name=\section,numberless}
{\normalfont\Large\bfseries\centering}
{}{0pt}{\MakeUppercase}
% ---------------------------------

\titleformat{\subsection}
{\normalfont\large\bfseries}
{}{0pt}{\thesection.\arabic{subsection} \space}

% Spacing between paragraphs
\setlength{\parindent}{1cm}
\setlength{\parskip}{1em}

% Hyperref (HARUS TERAKHIR)
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    filecolor=black,
    urlcolor=blue,
}

% ===================================================================
% INFORMASI DOKUMEN
% ===================================================================

\newcommand{\thetitle}{PERBANDINGAN EFISIENSI REST API DAN GRAPHQL PADA SISTEM PENJADWALAN PERKULIAHAN BERBASIS CLOUD-NATIVE DENGAN DOCKER, KUBERNETES, DAN LOAD BALANCING}

\newcommand{\theauthor}{Reyhan Capri Moraga}
\newcommand{\printnim}{123140022}

% Format tanggal Indonesia
\newcommand{\todayIndo}{\number\day\space\ifcase\month\or
Januari\or Februari\or Maret\or April\or Mei\or Juni\or
Juli\or Agustus\or September\or Oktober\or November\or Desember\fi
\space\number\year}

\begin{document}
\thispagestyle{empty}

% ===================================================================
% COVER
% ===================================================================

\begin{center}
    \smallskip
    
    \begin{center}
        \fontsize{11pt}{11pt}
        \bfseries \MakeUppercase{\thetitle}
        \vfill
        \uppercase{PROPOSAL PENELITIAN AWAL}
        \vfill
        \normalfont Tugas Mata Kuliah Metodologi Penelitian (IF25-41029)\\
        Program Studi Teknik Informatika\\
        Institut Teknologi Sumatera
        \vfill
    \end{center}

    \large \bfseries Oleh:\\
    \large \bfseries \theauthor\\
    \printnim
    \vfill
    
    \begin{figure}[h]
        \centering
        \includegraphics[width=3cm]{Figure/Logo_ITERA.png}
    \end{figure}
    \vfill

    \begin{center}
        \fontsize{11pt}{11pt}
        \bfseries
        \uppercase{
            Program Studi Teknik Informatika\\
            Institut Teknologi Sumatera\\
            2025
        }
    \end{center}
\end{center}

% =========================
% DAFTAR ISI (Halaman 2)
% =========================
\newpage
\thispagestyle{empty}

\section*{\centering \MakeUppercase{DAFTAR ISI}}
\addcontentsline{toc}{section}{DAFTAR ISI}

\vspace{1em}

% Hilangkan judul default dari \tableofcontents
\begingroup
\renewcommand{\contentsname}{}
\tableofcontents
\endgroup

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% BODY DOCUMENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section[BAB I PENDAHULUAN]{BAB I \protect\\ PENDAHULUAN}

\subsection{Latar Belakang}
Transformasi digital di sektor pendidikan tinggi telah mendorong peningkatan ekspektasi terhadap ketersediaan dan performa layanan akademik. Sistem informasi krusial, seperti sistem penjadalan perkuliahan, dituntut untuk tidak hanya fungsional tetapi juga harus skalabel dan responsif, terutama saat menghadapi lonjakan lalu lintas data (traffic) secara tiba-tiba, seperti pada masa pengisian Rencana Studi Mahasiswa (RSM) \cite{pratama2021}. Untuk menjawab tantangan ini, arsitektur aplikasi modern telah beralih dari sistem monolitik menuju arsitektur cloud-native yang memanfaatkan teknologi seperti kontainerisasi (Docker) dan orkestrasi (Kubernetes) untuk mencapai skalabilitas elastis dan ketahanan sistem (resilience) \cite{wang2022}. Dalam arsitektur ini, mekanisme load balancing menjadi krusial untuk mendistribusikan lalu lintas data secara merata ke berbagai copy layanan (kontainer), memastikan tidak ada satu layanan pun yang kelebihan beban dan meningkatkan ketersediaan layanan \cite{sharma2021}.

Inti dari sistem terdistribusi ini adalah Application Programming Interface (API), yang berfungsi sebagai jembatan komunikasi antar layanan. Selama bertahun-tahun, REST (Representational State Transfer) telah menjadi standar de-facto dalam perancangan API karena kesederhanaan dan adopsinya yang luas \cite{hartanto2021}. Namun, seiring dengan meningkatnya kompleksitas relasi data pada aplikasi modern—seperti sistem penjadalan yang melibatkan entitas mahasiswa, dosen, mata kuliah, dan ruangan—kelemahan REST mulai terlihat, terutama masalah over-fetching (mengambil data berlebih) dan under-fetching (memerlukan banyak request untuk mendapatkan data lengkap) \cite{cerny2021}.

Sebagai alternatif, GraphQL muncul sebagai query language untuk API yang menawarkan fleksibilitas tinggi, memungkinkan klien untuk meminta data yang spesifik hanya dengan satu request \cite{suryadi2022}. Sejumlah penelitian telah berupaya membandingkan efisiensi kedua arsitektur ini. Banyak studi awal, seperti yang dilakukan oleh Hartanto \cite{hartanto2021} dan Cerny \& Donahoo \cite{cerny2021}, berfokus pada perbandingan performa dalam lingkungan aplikasi monolitik atau lingkungan pengujian lokal. Studi-Sistem-studi ini umumnya menemukan bahwa GraphQL unggul dalam mengurangi ukuran payload dan waktu respons untuk query yang kompleks.

Meskipun demikian, terdapat celah penelitian (research gap) yang signifikan. Sangat sedikit penelitian yang mengevaluasi kedua arsitektur API ini dalam konteks cloud-native yang sesungguhnya \cite{wang2022, suryadi2022}. Kinerja di lingkungan laboratorium (monolitik) mengabaikan variabel dinamis produksi seperti overhead latensi keamanan (misal, validasi token) \cite{wibowo2021}, latensi jaringan antar-layanan, service discovery, dan dampak langsung dari algoritma load balancing Kubernetes terhadap distribusi beban. Perbandingan yang adil (fair comparison) di lingkungan yang lebih realistis ini masih sangat dibutuhkan.

Oleh karena itu, penelitian ini akan melakukan analisis perbandingan efisiensi REST API dan GraphQL pada studi kasus sistem penjadalan perkuliahan, yang diimplementasikan sebagai testbed yang adil di atas platform cloud-native (Docker, Kubernetes) dan diuji menggunakan skenario load balancing untuk mensimulasikan beban kerja dunia nyata.

\subsection{Rumusan Masalah}

\begin{enumerate}[nolistsep]
    \item Bagaimana merancang sebuah testbed perbandingan yang adil (fair comparison) untuk prototipe backend REST dan GraphQL, yang mencakup simulasi overhead latensi keamanan (mock middleware), di atas platform Docker dan Kubernetes?
    \item Seberapa signifikankah perbedaan kinerja (ditinjau dari throughput, latency, dan payload size) antara REST dan GraphQL saat diuji dengan skenario query yang bervariasi: (a) query sederhana (data tunggal), (b) query kompleks (relasi data majemuk), dan (c) simulasi under-fetching REST?
    \item Manakah arsitektur API yang menunjukkan skalabilitas dan ketahanan (resilience) lebih baik ketika dihadapkan pada skenario beban tinggi (high load) yang didistribusikan melalui load balancer Kubernetes?
\end{enumerate}

\subsection{Tujuan Penelitian}

\begin{enumerate}[nolistsep]
    \item Merancang dan mengimplementasikan prototipe backend sistem penjadwal (REST dan GraphQL) dengan jaminan fairness—termasuk implementasi mock middleware latensi—dan menjalankannya sebagai testbed di atas platform Docker dan Kubernetes.
    \item Menganalisis secara kuantitatif perbedaan kinerja kedua API pada tiga skenario query spesifik (sederhana, kompleks, dan simulasi under-fetching) untuk metrik throughput, latency, dan payload size.
    \item Mengevaluasi dan menentukan arsitektur API yang memiliki skalabilitas dan ketahanan (resilience) superior di bawah skenario pengujian beban tinggi (stress testing) dengan load balancing.
\end{enumerate}

\subsection{Batasan Masalah}

\begin{enumerate}[nolistsep]
    \item Penelitian berfokus pada perbandingan performa API di sisi backend. Aspek frontend (UI/UX) dari aplikasi penjadwal tidak akan dikembangkan atau dievaluasi.
    \item Logika bisnis atau algoritma untuk generating jadwal perkuliahan (misalnya, penyelesaian konflik jadwal) berada di luar cakupan penelitian. Sistem dianggap sudah memiliki data jadwal yang siap diakses melalui API.
    \item Pengujian dilakukan dalam lingkungan cluster Kubernetes yang terkontrol. Variabel spesifik dari penyedia layanan cloud publik (seperti AWS, GCP, atau Azure) tidak akan dibahas secara mendalam.
    \item Penelitian ini tidak mengimplementasikan sistem keamanan (otentikasi/otorisasi) secara fungsional. Namun, sebuah mock middleware yang mensimulasikan overhead latensi konstan (misal: 1-2ms untuk validasi token) akan ditambahkan pada kedua API untuk menjamin fairness perbandingan yang lebih mendekati kondisi nyata.
    \item Penelitian tidak berfokus pada optimasi query di database layer. Kinerja basis data diasumsikan setara dan konstan untuk kedua API, yang akan menggunakan skema dan query data mentah yang serupa.
    \item Upaya fairness dilakukan pada logika bisnis, namun perbedaan performa minor yang berasal dari library atau framework-specific (misal: ORM, GraphQL resolver) merupakan batasan yang diketahui.
\end{enumerate}

\subsection{Kontribusi Penelitian}

\begin{enumerate}[nosep]
    \item Menyajikan data empiris dan analisis baru mengenai perbandingan performa REST API vs. GraphQL dalam konteks arsitektur cloud-native melalui sebuah testbed perbandingan yang adil (fair comparison) dan lebih mendekati skenario nyata (memasukkan simulasi overhead latensi dan load balancing).
    \item Memberikan rekomendasi berbasis data bagi para arsitek sistem dalam memilih arsitektur API yang paling efisien untuk aplikasi berskala besar, khususnya yang memiliki karakteristik relasi data kompleks dan pola lalu lintas spiky (padat pada waktu-waktu tertentu).
    \item Menghasilkan blueprint dan prototipe sistem sebagai testbed yang dapat direplikasi untuk penelitian lebih lanjut mengenai optimasi performa API di lingkungan cloud-native.
\end{enumerate}

\newpage

\section{BAB 2. TINJAUAN PUSTAKA}

\subsection{Arsitektur Cloud-Native dan Microservices}
Transformasi arsitektur perangkat lunak telah bergeser secara signifikan dari model monolitik menuju microservices. Dalam konteks cloud-native, aplikasi dibangun sebagai sekumpulan layanan kecil yang independen dan terisolasi dalam kontainer (seperti Docker). Wang dan Li (2022) menjelaskan bahwa arsitektur ini menawarkan skalabilitas elastis dan fault isolation yang lebih baik dibandingkan monolitik. Namun, pergeseran ini memperkenalkan kompleksitas baru dalam komunikasi antar-layanan, di mana efisiensi pertukaran data melalui Application Programming Interface (API) menjadi faktor kritis yang menentukan performa sistem secara keseluruhan. Orkestrasi menggunakan Kubernetes menjadi standar industri untuk mengelola lifecycle kontainer ini, termasuk fitur auto-scaling dan self-healing.

\subsection{Perbandingan Arsitektur API: REST vs GraphQL}

\subsubsection{REST (Representational State Transfer)}
REST telah menjadi standar de-facto untuk desain API selama bertahun-tahun. Karakteristik utamanya adalah statelessness dan penggunaan metode HTTP standar (GET, POST, PUT, DELETE) untuk memanipulasi sumber daya. Kelebihan REST terletak pada kesederhanaannya dan kemampuan caching yang baik pada level HTTP. Namun, Cerny dan Donahoo (2021) menyoroti kelemahan fundamental REST dalam aplikasi data-sentris yang kompleks, yaitu masalah over-fetching (klien menerima data lebih banyak dari yang dibutuhkan) dan under-fetching (klien memerlukan beberapa request ke endpoint berbeda untuk mendapatkan data relasional).

\subsubsection{GraphQL}
Sebagai respon terhadap keterbatasan REST, Facebook memperkenalkan GraphQL, sebuah query language untuk API. Berbeda dengan REST yang memiliki banyak endpoint, GraphQL mengekspos satu endpoint tunggal yang memungkinkan klien mendefinisikan struktur data persis yang dibutuhkan. Suryadi (2022) dalam studinya menemukan bahwa GraphQL secara signifikan mengurangi ukuran payload data pada aplikasi mobile, yang berimplikasi langsung pada efisiensi bandwidth. Fitur schema-first design pada GraphQL juga memudahkan evolusi API tanpa merusak kompatibilitas dengan klien lama.

\subsection{Mekanisme Load Balancing pada Kubernetes}
Dalam lingkungan Kubernetes, load balancing berfungsi mendistribusikan lalu lintas jaringan ke berbagai pod (replika layanan) untuk menjamin ketersediaan dan responsivitas. Sharma dan Gupta (2021) menganalisis berbagai algoritma load balancing (seperti Round Robin dan Least Connection) dan menyimpulkan bahwa efisiensi distribusi beban sangat dipengaruhi oleh karakteristik request. Pada konteks perbandingan API, cara load balancer (seperti Nginx Ingress atau Service tipe LoadBalancer) menangani request HTTP (REST) versus payload POST tunggal (GraphQL) dapat mempengaruhi latensi total sistem, sebuah aspek yang jarang dibahas dalam studi komparasi API tradisional.

\subsection{State of the Art dan Research Gap}
Terdapat sejumlah penelitian yang membandingkan performa REST dan GraphQL. Hartanto (2021) melakukan perbandingan pada aplikasi e-commerce monolitik dan menemukan GraphQL lebih unggul dalam fleksibilitas data. Studi lain oleh Wang dan Li (2022) mulai menyentuh aspek microservices, namun pengujian dilakukan pada lingkungan lokal tanpa orkestrasi yang kompleks.

Kelemahan utama dari literatur yang ada adalah mayoritas pengujian dilakukan dalam lingkungan yang terisolasi atau monolitik, mengabaikan variabel dinamis yang ada pada lingkungan produksi cloud-native modern. Variabel seperti overhead jaringan antar-pod dalam klaster Kubernetes, latensi yang diperkenalkan oleh ingress controller atau load balancer, serta dampak keamanan (validasi token pada middleware) seringkali tidak diperhitungkan.

Research Gap: Belum ada studi komprehensif yang membandingkan efisiensi REST API dan GraphQL secara head-to-head dalam skenario "dunia nyata" yang melibatkan arsitektur cloud-native penuh dengan Kubernetes, load balancing, dan simulasi latensi keamanan. Penelitian ini hadir untuk mengisi celah tersebut dengan merancang testbed yang adil (fair comparison) untuk mengukur dampak arsitektur API terhadap performa sistem berskala besar.

\newpage

\section{BAB 3. METODOLOGI PENELITIAN}

\subsection{Kerangka Penelitian}
Penelitian ini akan dilaksanakan mengikuti alur kerja sistematis untuk menjamin validitas hasil eksperimen. Kerangka penelitian digambarkan dalam tahapan berikut:

\begin{enumerate}
    \item \textbf{Studi Literatur:} Memperdalam pemahaman tentang REST, GraphQL, Docker, Kubernetes, dan metrik evaluasi kinerja.
    \item \textbf{Perancangan Sistem (Design):} Merancang arsitektur microservices untuk sistem penjadwalan kuliah, skema basis data, dan spesifikasi API (OpenAPI untuk REST dan Schema GraphQL).
    \item \textbf{Implementasi Testbed:} Membangun lingkungan pengujian yang terdiri dari klaster Kubernetes, konfigurasi load balancer, dan pengembangan layanan backend (dua versi: REST dan GraphQL) beserta mock middleware keamanan.
    \item \textbf{Pengujian \& Pengumpulan Data:} Menjalankan skenario uji beban (load testing) menggunakan alat bantu otomatisasi untuk mengukur metrik kinerja.
    \item \textbf{Analisis Hasil:} Membandingkan data yang diperoleh secara statistik untuk menjawab rumusan masalah.
    \item \textbf{Penarikan Kesimpulan:} Menyimpulkan arsitektur mana yang lebih efisien berdasarkan bukti empiris.
\end{enumerate}

\subsection{Metode Perancangan dan Pengembangan}
Sistem yang dikembangkan bukanlah aplikasi produksi penuh, melainkan sebuah Prototipe Testbed yang dirancang khusus untuk memfasilitasi perbandingan yang adil (fair comparison).

\textbf{Arsitektur Sistem:} Menggunakan pola microservices sederhana yang dijalankan di atas Docker container dan diorkestrasi oleh Kubernetes (Minikube atau K3s).

\textbf{Komponen Backend:}
\begin{itemize}
    \item \textbf{Layanan REST:} Dibangun menggunakan Node.js (Express) atau Go (Gin), menyediakan endpoint terpisah untuk entitas Mahasiswa, Dosen, Mata Kuliah, dan Jadwal.
    \item \textbf{Layanan GraphQL:} Dibangun menggunakan teknologi setara (misal Apollo Server), menyediakan satu endpoint /graphql dengan resolver yang memetakan ke struktur data yang sama.
    \item \textbf{Database:} Menggunakan PostgreSQL atau MongoDB yang sama persis untuk kedua layanan guna mengeliminasi bias pada lapisan data.
    \item \textbf{Fairness Mechanism:} Kedua layanan akan dilengkapi dengan mock middleware yang menyuntikkan latensi sintetis (misal: 10ms) pada setiap request untuk mensimulasikan proses otentikasi/otorisasi (JWT validation) tanpa melakukan komputasi kriptografi berat yang tidak relevan dengan tujuan penelitian.
\end{itemize}

\subsection{Metode Pengumpulan Data}
Data penelitian ini termasuk dalam kategori Data Primer Kuantitatif yang diperoleh melalui eksperimen terkontrol (benchmarking).

\textbf{Instrumen Pengujian:} Menggunakan tools uji beban modern seperti k6 atau JMeter. Alat ini akan bertindak sebagai klien yang mengirimkan ribuan request ke sistem.

\textbf{Skenario Pengujian:}
\begin{enumerate}
    \item \textbf{Skenario A (Single Resource):} Mengambil data profil satu mahasiswa. (Menguji overhead dasar protokol).
    \item \textbf{Skenario B (Nested Resource/Complex Query):} Mengambil data jadwal kuliah seorang mahasiswa beserta detail mata kuliah dan nama dosen pengampunya. (Menguji kemampuan fetching data relasional).
    \item \textbf{Skenario C (High Concurrency/Stress Test):} Mengirimkan beban tinggi (misal: 1000 virtual users bersamaan) untuk melihat titik jenuh (breaking point) dan perilaku load balancer.
\end{enumerate}

\textbf{Metrik yang Diukur:}
\begin{itemize}
    \item \textbf{Response Time / Latency (ms):} Rata-rata, P95, dan P99.
    \item \textbf{Throughput (Requests per Second / RPS).}
    \item \textbf{Payload Size (Kilobytes):} Ukuran data yang dikirim melalui jaringan.
    \item \textbf{Resource Utilization:} Penggunaan CPU dan Memori pada kontainer (dipantau menggunakan metrics-server Kubernetes atau Prometheus).
\end{itemize}

\subsection{Metode Pengujian dan Evaluasi (Verifikasi \& Validasi)}
Untuk memastikan hasil penelitian valid dan reliabel, rencana V\&V berikut akan diterapkan:

\textbf{Verifikasi Fungsional:} Sebelum uji beban, dilakukan Unit Testing dan Integration Testing sederhana untuk memastikan kedua API (REST dan GraphQL) mengembalikan data yang benar dan identik secara semantik untuk input yang sama.

\textbf{Validasi Lingkungan:} Memastikan kondisi cluster Kubernetes "bersih" dan stabil sebelum setiap pengambilan data. Menggunakan teknik warm-up runs sebelum pencatatan data aktual untuk menghindari bias akibat cold start pada aplikasi (khususnya yang berbasis JIT seperti Node.js atau Java).

\textbf{Analisis Statistik:} Data hasil eksperimen tidak hanya dilihat rata-ratanya, tetapi juga dianalisis standar deviasinya untuk melihat konsistensi performa. Uji hipotesis (seperti T-Test) akan digunakan jika diperlukan untuk menentukan apakah perbedaan performa yang diamati signifikan secara statistik.

\newpage

\renewcommand{\refname}{DAFTAR PUSTAKA}
\bibliographystyle{IEEEtran}
\bibliography{Referensi}

\end{document}